---
title: Third Tutorial for R4DS
author: Luke Li, David Kane, and Sruthi Gandhi
tutorial:
  id: r4ds-3
output: 
  learnr::tutorial:
    df_print: default
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description: 'This tutorial for "R for Data Science" covers Chapter 12: Logical vectors, Chapter 13: Numbers, Chapter 14: Strings, Chapter 15: Regular expressions, and Chapter 21: Databases.'
---

```{r setup, include = FALSE}
library(learnr)
library(tutorial.helpers)

library(tidyverse)
library(babynames)
library(nycflights13)
library(DBI)
library(duckdb)
library(dbplyr)

knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 600, 
        tutorial.storage = "local") 

# duck db connections
con_names <- dbConnect(duckdb::duckdb(), 
				 dbdir = "data/nameby_year.duckdb")
con_air <- dbConnect(duckdb::duckdb(), 
				 dbdir = "data/nycflights13.duckdb")

#making lazy table for dbplyr use
dbplyr_names <- tbl(con_names, "babynames")
dbplyr_fly <- tbl(con_air, "flights")

#babynames plot
x <-  dbplyr_names |>
filter(str_starts(name, "A"), year > 2000, n >= 10) |>
mutate(length_class = if_else(str_length(name) <= 5, "Short", "Long"))

data <- flights |>
  select(dep_time, sched_dep_time, dep_delay, tailnum) |>
  mutate(tail_number = parse_number(tailnum)) |>
  filter(!is.na(dep_time))

#flights plot
departure_data <- data |> 
  mutate(
    dep_hour = dep_time %/% 100,
    dep_minute = dep_time %% 100,
    sched_hour = sched_dep_time %/% 100,
    sched_minute = sched_dep_time %% 100,
    true_dep_delay = pmax(dep_delay, 0)
  ) |>
  count(sched_hour, dep_hour, wt = true_dep_delay, name = "total_delay")
```

```{r info-section, child = system.file("child_documents/info_section.Rmd", package = "tutorial.helpers")}
```

## Introduction
### 

This section covers key concepts from [Chapter 13: Numbers](https://r4ds.hadley.nz/numbers.html), [Chapter 14: Strings](https://r4ds.hadley.nz/strings.html), [Chapter 15: Regular Expressions](https://r4ds.hadley.nz/regexps.html), [Chapter 12: Logical Vectors](https://r4ds.hadley.nz/logicals.html), and [Chapter 21: Databases](https://r4ds.hadley.nz/databases.html) from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund.

You will learn about working with numeric data and text patterns using core *Tidyverse* packages like **readr**, **dplyr**, and **stringr**, as well as database interaction using **dbplyr**. Important functions include: [parse_number()](https://readr.tidyverse.org/reference/parse_number.html), [is.na()](https://rdrr.io/r/base/NA.html), [str_detect()](https://stringr.tidyverse.org/reference/str_detect.html), [pmax()](https://rdrr.io/r/base/Extremes.html), [`str_c()`](https://stringr.tidyverse.org/reference/str_c.html), [`str_flatten()`](https://stringr.tidyverse.org/reference/str_flatten.html), [`dbWriteTable()`](https://rdrr.io/cran/DBI/man/dbWriteTable.html), and [`dbConnect()`](https://rdrr.io/cran/DBI/man/dbConnect.html). 

You will also explore logical operations with `if_else()`, and concepts like integer division and modulo. This knowledge will help you manipulate numbers, strings, logical vectors, and connect with DuckDB databases using SQL from within R.

### Exercise 1

Create a Github repo called `r4ds-3`. Set the "Add README" toggle switch to "On."

Connect the repo to a project on your computer using `File -> New Folder from Git ...`. Make sure to select the "Open in a new window" box.

You need two Positron windows: this one for running the tutorial and the one you just created for writing your code and interacting with the Console.

Select `File -> New File -> Quarto Document ...`. Provide a title -- `"Analyzing Baby Names and Flights"` -- and an author (you). Render the document and save it as `analysis.qmd`.

Create a `.gitignore` file with `analysis_files` on the first line and then a blank line. Save and push.

In the Console, run:

```         
show_file(".gitignore")
```

If that fails, it is probably because you have not yet loaded `library(tutorial.helpers)` in the Console.

CP/CR.

```{r introduction-1}
question_text(NULL,
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL,
    rows = 3)
```

### 

We will be working with databases in this tutorial. There are two key differences between data frames and database tables:

-   Database tables are stored on disk and can be arbitrarily large. Data frames are stored in memory, and are fundamentally limited (although that limit is still plenty large for many problems).

-   Database tables almost always have indexes. Much like the index of a book, a database index makes it possible to quickly find rows of interest without having to look at every single row. Data frames and tibbles don’t have indexes, but data.tables (from the [**data.table**](https://rdatatable.gitlab.io/data.table/) package) do, which is one of the reasons that they’re so fast.

### Exercise 2

In your QMD, put `library(tidyverse)`, `library(DBI)`, `library(duckdb)`, and `library(dbplyr)` in a new code chunk. Render the file using `Cmd/Ctrl + Shift + K`.

Notice that the file does not look good because the code is visible and there are annoying messages. To take care of this, add `#| message: false` to remove all the messages in this `setup` chunk. Also add the following to the YAML header to remove all code echoes from the HTML:

```         
execute: 
  echo: false
```

Render the file using `Cmd/Ctrl + Shift + K`. In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r introduction-2}
question_text(NULL,
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL,
    rows = 6)
```

### 

Databases are run by database management systems (DBMS’s for short), which come in three basic forms:

-   Client-server DBMS’s run on a powerful central server, which you connect from your computer (the client). They are great for sharing data with multiple people in an organization.

-   Cloud DBMS’s, are similar to client server DBMS’s, but they run in the cloud. This means that they can easily handle extremely large datasets and can automatically provide more compute resources as needed.

-   In-process DBMS’s run entirely on your computer. They’re great for working with large datasets where you’re the primary user.

### Exercise 3

Place your cursor in the QMD file at the start of the `library(tidyverse)` line. Use `Cmd/Ctrl + Enter` to execute that line.

<!-- DK: Don't we want to execute all the libraries? What command does that? -->

Note that this causes `library(tidyverse)` to be copied down to the Console and then executed.

CP/CR.

```{r introduction-3}
question_text(NULL,
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL,
    rows = 3)
```

### 

For this tutorial, we will be working with the babynames database. At the simplest level, you can think about a database as a collection of data frames, called tables in database terminology. Like a data frame, a database table is a collection of named columns, where every value in the column is the same type.

### Exercise 4

From the Console, run these three commands:

`getwd()`
`dir.create("data")`
`list.files()`

This will create a `data` directory in your project. This is a good place to store any data that you are working with.

CP/CR

```{r introduction-4}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Your answer should look something like, although your path will be different.

````
> getwd()
[1] "/Users/dkane/Desktop/projects/XX"
> dir.create("data")
> list.files()
 [1] "analysis.qmd"        "data"    "README.md"
>
````


## Baby names
### 

In this section we are going to focus on generating code to create a graph based on a database called `nameby_year.duckdb`. The data in this database comes from `babynames`, which is a dataset that contains names used for American babies from 1880 to 2017. If you want to explore related data, checkout [popular baby names](https://www.ssa.gov/oact/babynames/limits.html). We will be using AI to generate the code for us and then we will break down the functions within the code and how they work.

Key functions you'll learn:

`DBI::dbConnect()` - Creates a connection to a database

`dbReadTable()` - Reads a complete table from a database into a data frame

`as_tibble()` - Converts data frames to tibbles for better printing and consistency

`tbl()` - Creates a lazy reference to a database table for use with dbplyr

`dbGetQuery()` - Executes a SQL query and returns the results as a data frame


### Exercise 1

We begin by downloading a DuckDB version of the babynames dataset directly from GitHub using `download.file()`. 

This stores the database file, `data/nameby_year.duckdb`, to our the `data` directory so we can use it in this tutorial.

In the Console, run:

```         
download.file(
  "https://github.com/PPBDS/ai.tutorials/raw/refs/heads/main/inst/tutorials/r4ds-3/data/nameby_year.duckdb",
  destfile = "data/nameby_year.duckdb"
)
```

CP/CR.

```{r baby-names-1}
 
 question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 

`nameby_year.duckdb` is currently a collection of binary files and is not ready to use until we create a database connection using `DBI::dbConnect()`. The first argument selects the DBMS, then the second and subsequent arguments describe how to connect to it (i.e. where it lives and the credentials that you need to access it).

### Exercise 2

Ask AI: how to connect the `nameby_year.duckdb` database located in the "data" directory to `duckdb` using `DBI::dbConnect()` by assigning it to a variable `con_names`, so it is accessible to use with the rest of the code in the document. Add the code to your QMD in a new chunk. Place your cursor on the first line of the code and run `Cmd/Ctrl + Enter`.

CP/CR.

  
```         
show_file("analysis.qmd", chunk = "Last")
```

```{r baby-names-2}
 question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 



```{r baby-names-2-hint-1, echo = TRUE, eval = FALSE}
con_names <- DBI::dbConnect(
    duckdb::duckdb(),
    dbdir = "data/nameby_year.duckdb"
  )
```

This creates a connection to the database and assigns it to the variable con, short for connection. This connection acts like a bridge between R and the DuckDB file. **DBI** is a low-level interface that connects to databases and executes SQL; **dbplyr** is a high-level interface that translates your **dplyr** code to SQL queries then executes them with **DBI**.


### Exercise 3

<!-- DK: Going to fast. What are the tables in this database? -->
The `nameby_year.duckdb` database contains one table: `babynames`.

Ask AI: how to start a pipe from `con_names` to retrieve the contents of the `babynames` table from the `nameby_year.duckdb` database using `dbReadTable()` and read it using `as_tibble()`. Make sure the result is not assigned to a variable. Add this code in a new code chunk to the QMD. Place your cursor on the first line of the code and run `Cmd/Ctrl + Enter`. 

```{r baby-names-3}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

```{r baby-names-3-test, echo = TRUE}
con_names |> 
    dbReadTable("babynames") |> 
    as_tibble()
```

###

`dbReadTable()`returns a data frame, not a tibble, so we pipe it into `as_tibble()` for the result to be a tibble.

### Exercise 4

Using your favorite AI, prompt it to generate SQL code that takes `babynames` and filters the dataset to show all names that have a first name starting with A after the year 2000. Make sure to provide some lines of **babynames** for the AI to use. If necessary, change the code so that the result of the pipe is assigned to a variable called "sql". Add the code as a replacement to the current code in your current chuck in the QMD. Place your cursor on the first line of the code and run `Cmd/Ctrl + Enter`.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r baby-names-4}

 question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 



```{r baby-names-4-test, echo = TRUE}

sql <- "
  SELECT name, year, sex, n, prop
  FROM babynames
  WHERE name LIKE 'A%' AND year > 2000
"
```

A query is made up of **clauses**. There are five important clauses: `SELECT`, `FROM`, `WHERE`, `ORDER BY`, and `GROUP BY`. Every query must have the `SELECT` and `FROM` clauses and the simplest query is `SELECT * FROM table`, which selects all columns from the specified table. `WHERE` and `ORDER BY` control which rows are included and how they are ordered, and `GROUP BY` converts the query to a summary, causing aggregation to happen.

### Exercise 5

You can use `dbGetQuery()` to get the results of running a query on the database. 

Ask AI: how to get the results of the query by using `dbGetQuery()`. Make sure to provide your code of the DBI connection and the SQL query.  Add this code to the same code chunk in your QMD and run `Cmd/Ctrl + Enter`.

```{r baby-names-5}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

```{r baby-names-5-test, echo = TRUE}
sql <- "
  SELECT name, year, sex, n, prop
  FROM babynames
  WHERE name LIKE 'A%' AND year > 2000
"

as_tibble(dbGetQuery(con_names, sql))
```

###

`as_tibble()` turns an existing object, such as a data frame or matrix, into a tibble, a data frame with class `tbl_df`. This is in contrast with `tibble()`, which builds a tibble from individual columns.

### Exercise 6

You just used SQL to filter the babynames database directly and ran a query to see your results. Although, instead of writing raw SQL yourself, we can do the exact same task with R code using `dbplyr`. `dbplyr` is a `dplyr` backend, which means that you keep writing `dplyr` code but the backend executes it differently. In this, `dbplyr` translates to SQL; other backends include `dbplyr` which translates to `data.table`, and `multidplyr` which executes your code on multiple cores. 

Replace the code in your current code chunk in your new QMD by pasting this code instead:

```         
 dbplyr_names <- tbl(con, "babynames")
```

CP/CR.

```{r baby-names-6}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 

To use `dbplyr`, you must first use `tbl()` to create an object that represents a database table. This is called a lazy table, which is a representation of a database table or query result that is not immediately materialized in R's memory. Instead, `dbplyr` translates `dplyr` operations performed on this lazy table into SQL queries. These queries are then sent to the database and executed there, with the results only being retrieved into R when explicitly requested (e.g., using `collect()`). 

### Exercise 7

Ask AI: how to use `dbplyr` to filter the data to show all names start with A after the year 2000 using `str_starts()`. Paste this code into the same code chunk and place your cursor at the start of `dbplyr_names` and run `Cmd/Ctrl + Enter`.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```
CP/CR.

```{r baby-names-7}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 



```{r baby-names-7-test, echo = TRUE}
dbplyr_names |>
  filter(name %like% "A%", year > 2000, n >= 10)
```

### 

**dplyr**’s `case_when()` is inspired by SQL’s `CASE` statement and provides a flexible way of performing different computations for different conditions. It has a special syntax that unfortunately looks like nothing else you’ll use in the tidyverse. It takes pairs that look like `condition ~ output`. `condition` must be a logical vector; when it’s `TRUE`, `output` will be used.

### Exercise 8

Paste your current pipe into AI and ask it for a continuation that uses `if_else()`, `str_length()`, and `length_class()` to create a new column of names classified as "Short" or "Long", where anything less than or equal to 5 is classified as short. Add this code as a continuation of your pipe to the same chunk in your QMD. Since the `babynames` is a data set which contains names used for babies from 1880 to 2017 in America, we are using the truncated average length of an American name during 2009: 5. 

Place your cursor on the first line of the code in your current code chunk at the start of `dbplyr_names` and run `Cmd/Ctrl + Enter`. 

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r baby-names-8}
 question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 



```{r baby-names-8-test, echo = TRUE}
 dbplyr_names |>
  filter(name %like% "A%", year > 2000, n >= 10) |>
  mutate(length_class = if_else(str_length(name) <= 5, "Short", "Long"))
```

`>=` is used when you want to find a variable that that is greater than or equal to a number. Conversely, you could use `<=` to find a variable that that is less than or equal to a number. Finally, `==` can be used to find a variable that is exactly equal to a number.

### Exercise 9

Prompt AI to continue the pipe by using `.by()` to summarize the data by grouping by `year` and `length_class`, calculating the total number of babies in each group by summing `n` using `sum()`. Add the code as a continuation of your pipe to your QMD in the same chunk. Place your cursor on the first line of the code in your current code chunk at the start of `dbplyr_names` and run `Cmd/Ctrl + Enter`. 

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

  
```{r baby-names-9}
 question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 



```{r baby-names-9-test, echo = TRUE}
 dbplyr_names |>
  filter(name %like% "A%", year > 2000, n >= 10) |>
  mutate(length_class = if_else(str_length(name) <= 5, "Short", "Long")) |> 
  summarize(total = sum(n), .by = c(year, length_class)) 
```

### 

The `.by` argument is a selection of columns to group by for just this operation, functioning as an alternative to `group_by()`. For details and examples, see `?dplyr_by`.

### Exercise 10

Prompt the AI to arrange the summarized results in ascending order by `year`, and collect the results from the database into a local R tibble for further use, such as plotting. Add the code to your QMD in the same chunk. Place your cursor on the first line of the code and run `Cmd/Ctrl + Enter`. Now, prompt the AI to arrange the summarized results in ascending order by year, and collect the results from the database into a local R tibble for further use, such as plotting. Add the code to your QMD in the same chunk. Place your cursor on the first line of the code in your current code chunk at the start of `dbplyr_names` and run `Cmd/Ctrl + Enter`.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

  
```{r baby-names-10}
 
 question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 



```{r baby-names-10-test, echo = TRUE}
dbplyr_names |>
	filter(name %like% "A%", year > 2000, n >= 10) |>
  	mutate(length_class = if_else(str_length(name) <= 5, "Short", "Long")) |> 
  	summarize(total = sum(n), .by = c(year, length_class)) |> 
	arrange(year) 
```

### 

Ordering rows involves a straightforward translation from `arrange()` to the SQL `ORDER BY` clause.

### Exercise 11

Now that we have filtered our dataset through a pipe, we need to be on track with the same, correct, code. Replace your last code chunk with our code in your QMD.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

  
```{r baby-names-11}
 
 question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 

```{r baby-names-11-test, echo = TRUE}
dbplyr_names |>
	filter(name %like% "A%", year > 2000, n >= 10) |>
  	mutate(length_class = if_else(str_length(name) <= 5, "Short", "Long")) |> 
  	summarize(total = sum(n), .by = c(year, length_class)) |> 
	arrange(year) |>
   	collect()
```

### 

To get all the data back into R, you call `collect()`. Behind the scenes, this generates the SQL, calls `dbGetQuery()` to get the data, then turns the result into a tibble.

### Exercise 12

Within the recent code chunk, add the option: `#| cache: true`. Assign the result of our pipe to `x`.

`Cmd/Ctrl + Shift + K`. By including `#| cache: true` you cause Quarto to cache the results of the chunk. The next time you render your QMD, as long as you have not changed the code, Quarto will just load up the saved fitted object.

Place your cursor on the line where the pipe is assigned to x, run `Cmd/Ctrl + Enter`. Now, the workspace also includes a copy of `x`.

CP/CR.

  
```{r baby-names-12}
 
 question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 



```{r baby-names-12-test, echo = TRUE}
 x <-  dbplyr_names |>
	filter(name %like% "A%", year > 2000, n >= 10) |>
  	mutate(length_class = if_else(str_length(name) <= 5, "Short", "Long")) |> 
  	summarize(total = sum(n), .by = c(year, length_class)) |> 
	arrange(year) |>
   	collect()

```

### 

<!-- XX: Insert a knowledge drop related to this project. -->

### Exercise 13

Within the Console, type `x`, which we previously assigned to a pipe and ran in the Console. Hit `Enter`.

CP/CR.   

```{r baby-names-13}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 

```{r baby-names-13-test, echo = TRUE}
x
```

### 

<!-- XX: Insert a knowledge drop related to this project. -->


### Exercise 14

Ask AI: to generate R code that plots a basic line graph showing the proportion of "Short" vs. "Long" names starting with A over the years (after 2000). Mention you want to use the data from `x` and copy and paste the `x` you ran in the Console with the resulting dataframe. You only need the top 3 lines, mainly to include column names.

Within `labs()` edit or add a proper title, subtitle, and caption. If axis labels are appropriate, add them, but if unnecessary, don't bother. Don't assign the code to any variable. Add this code as a replacement to the code in your current code cell. Run `Cmd/Ctrl + Shift + K`.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r baby-names-14}
 
 question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 


```{r baby-names-14-test, fig.keep = FALSE, echo = TRUE}
ggplot(x, aes(x = year, y = total, color = length_class)) +
  geom_line(linewidth = 1.2) +
  labs(
    title = "Trends in Short vs Long A-Names Since 2000",
	subtitle = "Long baby names starting with A are becoming less popular",
    x = "Year", 
    y = "Total Babies",
    color = "Name Length",
	caption = "Source: Babynames"
  ) +
  theme_minimal()
```

### 

<!-- XX: Insert a knowledge drop related to this project. -->

### Exercise 15

Publish your rendered QMD to GitHub Pages. In the Terminal --- not the Console! --- run:

```         
quarto publish gh-pages analysis.qmd
```

Copy/paste the resulting URL below.

  
```{r baby-names-15}
 
 question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 

Commit/push everything.


## Flights
### 

This section covers key concepts from [Chapter 13: Numbers](https://r4ds.hadley.nz/numbers.html) and [Chapter 15: Regular Expressions](https://r4ds.hadley.nz/regexps.html) from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. You will learn about some of the power of working with numeric data and text patterns using core Tidyverse packages: readr, dplyr, and stringr. 

Key functions you'll learn: 

[`parse_number()`](https://readr.tidyverse.org/reference/parse_number.html) - Parses the first number it finds

[`is.na()`](https://rdrr.io/r/base/NA.html) - Indicates which elements are missing

[`str_detect()`](https://stringr.tidyverse.org/reference/str_detect.html) - Returns a logical vector with TRUE for each element of string that matches pattern

[`pmax()`](https://rdrr.io/r/base/Extremes.html) - return a single vector giving the maxima of the argument vectors

We will also learn about integer division and moduluo.

In this section we are going to focus on generating code to create a graph based on a dataset called `nycflights13`. The `nycflights13` is a dataset which contains information about all flights departing from New York City airports in 2013. We will be using AI to generate the code for us and then we will break down the functions within the code and how they work. 


### Exercise 1

We begin by downloading a DuckDB version of the flights dataset directly from GitHub using `download.file()`. 

This stores the database file, `data/nycflights13.duckdb`, to our the `data` directory so we can use it in this tutorial.

In the Console, run:

```         
download.file(
  "https://github.com/PPBDS/ai.tutorials/raw/refs/heads/main/inst/tutorials/r4ds-3/data/nycflights13.duckdb",
  destfile = "data/nycflights13.duckdb"
)
```

CP/CR.

```{r flights-1}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###


### Exercise 2

Ask AI: how to connect the `flights` table from the `nycflights13` database located in the "data" directory to `duckdb` using `DBI::dbConnect()` by assigning it to a variable `con_air`, so it is accessible to use with the rest of the code in the document. Add the code to your QMD in a new chunk. Place your cursor on the first line of the code and run `Cmd/Ctrl + Enter`.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r flights-2}
 
 question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 



```{r flights-2-test, echo = TRUE, eval = FALSE}
con_air <- DBI::dbConnect(
    duckdb::duckdb(),
    dbdir = "data/nycflights13.duckdb"
  )
```

### 

Run `dbListTables()` on `con_air` to lists all tables in the database.


### Exercise 3

The `nycflights13.duckdb` database has multiple tables: `airlines`, `airports`, `flights`, `planes`, and `weather`.

Ask AI: how to start a pipe from `con_air` to retrieve the contents of the `flights` table from the `nycflights13.duckdb` database using `dbReadTable()` and convert it to a tibble using `as_tibble()`. Make sure the result is not assigned to a variable. Add this code in a new code chunk to the QMD. Place your cursor on the first line of the code and run `Cmd/Ctrl + Enter`. 

```{r flights-3}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

```{r flights-3-test, echo = TRUE}
con_air |>
    dbReadTable("flights") |> 
    as_tibble()
```

###

`dbGetQuery()` is a function which takes a connection and an SQL query as a text string as inputs. It returns the result of that query as a data frame. 

### Exercise 4

To use `dbplyr`, you must first use `tbl()` to create an object that represents a database table, called a lazy table.

Paste this code as a replacement to your current code in the same chunk in your QMD:

```         
 dbplyr_fly <- tbl(con_air, "flights")
```

 View the data by putting `dbplyr_fly` in your Console. Copy/paste the resulting lazy table.

```{r flights-4}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 



```{r flights-4-test, echo = TRUE}
 dbplyr_fly <- tbl(con_air, "flights")
 dbplyr_fly
```

### 

<!-- XX: Insert a knowledge drop related to this project. -->

### Exercise 5

View the `tailnum` column by pasting this in your console:

```         
flights$tailnum
```

Ask AI: how to check the column type of `tailnum` from the `flights` table using `class()`. Add the code to your Console and hit `Enter`.

CP/CR.

```{r flights-5}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 



```{r flights-5-test, echo = TRUE}
class(flights$tailnum)
```

### 

[[ and $ can be used to extract columns out of a data frame. [[ can access by position or by name, and $ is specialized for access by name:

### Exercise 6

The column type of `tailnum` is character. 

Ask AI: to clean the `flights` table by selecting the columns `dep_time`, `sched_dep_time`, `dep_delay`, and `tailnum`. Then, create a new column called `tail_number` by extracting numeric values from the character column `tailnum` using the `parse_number()` function. Add the code to your QMD in a new chunk. Assign this pipe to `departure_data`. Place your cursor on the first line of the code and run `Cmd/Ctrl + Enter`.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

```{r flights-6}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 



```{r flights-6-test, echo = TRUE}
departure_data <- flights |>
  select(dep_time, sched_dep_time, dep_delay, tailnum) |>
  mutate(tail_number = parse_number(tailnum)) 
```

### 

Use `parse_number()` when the string contains non-numeric text that you want to ignore. This is particularly useful for currency data and percentages.

### Exercise 7

 Ask your favorite AI to write code that summarizes how many missing values are in the `dep_time` and `arr_time` columns using the function `is.na()`. Add the code to your QMD in a new chunk. Place your cursor on the first line of the code and run `Cmd/Ctrl + Enter`.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

```{r flights-7}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 



```{r flights-7-test, echo = TRUE}
flights |> 
  summarise(
    missing_dep = sum(is.na(dep_time)),
    missing_arr = sum(is.na(arr_time))
  )
```

Delete this code cell.
 <!--SG: where should I put these -->


We have a lot of missing values that needs to be cleaned.  `is.na(x)` works with any type of vector and returns TRUE for missing values and FALSE for everything else, which we can use to find all the rows with a missing `dep_time`. To check for `NA` values, use `any()` function with argument `is.na()`, argument of which should be the dataset babynames.

### Exercise 8

Ask AI: how you can continue your previous pipe and filters out rows where dep_time is missing using `!is.na()`. Add the code to your QMD in the same chunk as an addition to the pipe that is assigned to `departure_data`. Place your cursor on the first line of the code and run `Cmd/Ctrl + Enter`. View your new cleaned data.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

```{r flights-8}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 

```{r flights-8-test, echo = TRUE}
departure_data <- flights |>
  select(dep_time, sched_dep_time, dep_delay, tailnum) |>
  mutate(tail_number = parse_number(tailnum)) |>
  filter(!is.na(dep_time))

departure_data
```

### 

`is.na()` can also be useful in `arrange()`. `arrange()` usually puts all the missing values at the end but you can override this default by first sorting with `is.na()`.The `arrange()` function is used to order rows in a data set based on a column. It allows you to sort the data set in either ascending or descending order.

### Exercise 9

Ask AI: how you can find tail numbers starting with "N1". Add the code to your QMD in a new code chunk. Place your cursor on the first line of the code and run `Cmd/Ctrl + Enter`.
In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

```{r flights-9}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 



```{r flights-9-test, echo = TRUE}
departure_data |>
  filter(str_detect(tailnum, "^N1")) |>
  count(tailnum, sort = TRUE)
```

### 
Delete this code cell. 

Since `str_detect()` returns a logical vector of the same length as the initial vector, it pairs well with `filter()` There are two functions that are closely related to `str_detect()`:\
\* `str_subset()` returns a character vector containing only the strings that match. 
\* `str_which()` returns an integer vector giving the positions of the strings that match.

Also, `n_distinct(x)` counts the number of distinct (unique) values of one or more variables. It is part of the same family of functions as `count()` and `n()`.

### Exercise 10

The scheduled departure time and the actual departure time for flights is written in the 24-hr system. Let's change this to the 12-hr system. Ask your favorite AI how to break military time into hours and minutes in R using integer division and modulo operators for the `sched_dep_time` and `dep_time` columns. Add the code to your QMD in a new code chunk. Place your cursor on the first line of the code and run `Cmd/Ctrl + Enter`.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

```{r flights-10}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 



```{r flights-10-test, echo = TRUE}
departure_data |>
  mutate(
    dep_hour = dep_time %/% 100,
    dep_minute = dep_time %% 100,
    sched_hour = sched_dep_time %/% 100,
    sched_minute = sched_dep_time %% 100
  )
```

### 

When combined with`%%` or `%/%`, `row_number()` can be a useful tool for dividing data into similarly sized groups. `row_number()` can also be used without any arguments when inside a `dplyr` verb.

### Exercise 11

Let's add a column for positive delays only. Ask the same AI how to continue the pipe and add `true_dep_delay` using `pmax(dep_delay, 0)` to treat early departures (negative delays) as 0. Then, how to use `count()` to group by `sched_hour` and `dep_hour`, weighing by `true_dep_delay` to get total delay minutes for each hour combination. Add the code to your QMD in the same code chunk as a continuation of your pipe. Place your cursor on the first line of the code and run `Cmd/Ctrl + Enter`.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

```{r flights-11}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 



```{r flights-11-test, echo = TRUE}
departure_data |>
  mutate(
    dep_hour = dep_time %/% 100,
    dep_minute = dep_time %% 100,
    sched_hour = sched_dep_time %/% 100,
    sched_minute = sched_dep_time %% 100,
    true_dep_delay = pmax(dep_delay, 0)
  ) |>
  count(sched_hour, dep_hour, wt = true_dep_delay, name = "total_delay")
```

### 

Note that these are different to the summary functions `min()` and `max()` which take multiple observations and return a single value. You can tell that you’ve used the wrong form when all the minimums and all the maximums have the same value.

### Exercise 12

Now that we have filtered our dataset through a pipe, we need to be on track with the same, correct, code. Replace your latest code chunk with our code in your QMD.

In the Console, run:

```         
show_file("XX.qmd", chunk = "Last")
```

CP/CR.

```{r flights-12}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 

```{r flights-12-test, echo = TRUE}
departure_data |>
  mutate(
    dep_hour = dep_time %/% 100,
    dep_minute = dep_time %% 100,
    sched_hour = sched_dep_time %/% 100,
    sched_minute = sched_dep_time %% 100,
    true_dep_delay = pmax(dep_delay, 0)
  ) |>
  count(sched_hour, dep_hour, wt = true_dep_delay, name = "total_delay")
```

### 

<!-- XX: Insert a knowledge drop related to this project. -->

### Exercise 13

Within the recent code chunk, add the option: `#| cache: true`. Assign the result of our pipe to `x`.

`Cmd/Ctrl + Shift + K`. By including `#| cache: true` you cause Quarto to cache the results of the chunk. The next time you render your QMD, as long as you have not changed the code, Quarto will just load up the saved fitted object.

Place your cursor on the line where the pipe is assigned to `x`, run `Cmd/Ctrl + Enter`. Now, the workspace also includes a copy of `x`.

CP/CR.

```{r flights-13}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 

```{r flights-13-test, echo = TRUE}
x <- departure_data |>
  mutate(
    dep_hour = dep_time %/% 100,
    dep_minute = dep_time %% 100,
    sched_hour = sched_dep_time %/% 100,
    sched_minute = sched_dep_time %% 100,
    true_dep_delay = pmax(dep_delay, 0)
  ) |>
  count(sched_hour, dep_hour, wt = true_dep_delay, name = "total_delay")
```

### 

<!-- XX: Insert a knowledge drop related to this project. -->

### Exercise 14

Within the Console, type `x`, which we previously assigned to a pipe and ran in the Console. Hit `Enter`.

CP/CR.

```{r flights-14}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 



```{r flights-14-test, echo = TRUE}
x
```

### 

<!-- XX: Insert a knowledge drop related to this project. -->

### Exercise 15

Go to the AI and ask it to generate R code that plots a beautiful heatmap using `geom_tile()` that shows where delays cluster by scheduled vs. actual departure hour. Mention you want to use the data from `x` and copy and paste the `x` you ran in the Console with the resulting tibble. You only need the top 3 lines, mainly to include column names.

Within `labs()` edit or add a proper title, subtitle, and caption. If axis labels are appropriate, add them, but if unnecessary, don't bother. Don't assign the code for the plot to any variable. Add this code to a new code cell. Run `Cmd/Ctrl + Shift + K`.

In the Console, run:

```         
show_file("XX.qmd", chunk = "Last")
```

CP/CR.

```{r flights-15}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

### 



```{r flights-15-test, echo = TRUE}
ggplot(x, aes(x = sched_hour, y = dep_hour, fill = total_delay)) +
  geom_tile(color = "white") +
  scale_fill_viridis_c(option = "plasma", name = "Total Delay\n(minutes)") +
  labs(
    title = "Flight Delay Patterns: Scheduled vs Actual Departure Hours",
    subtitle = "Darker regions show higher total delay concentrations",
    x = "Scheduled Departure Hour",
    y = "Actual Departure Hour", 
    caption = "Source: nycflights13 dataset"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 12)
  )
```

### 

Once you map an aesthetic, **ggplot2** takes care of the rest. It selects a reasonable scale to use with the aesthetic, and it constructs a legend that explains the mapping between levels and values. For x and y aesthetics, **ggplot2** does not create a legend, but it creates an axis line with tick marks and a label. The axis line provides the same information as a legend; it explains the mapping between locations and values.

## Summary

### 

This tutorial covered [Chapter 12: Logical vectors](https://r4ds.hadley.nz/logicals.html), [Chapter 13: Numbers](https://r4ds.hadley.nz/numbers.html), [Chapter 14: Strings](https://r4ds.hadley.nz/strings.html), [Chapter 15: Regular expressions](https://r4ds.hadley.nz/regexps.html), and [Chapter 16: Factors](https://r4ds.hadley.nz/factors.html), from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund.

You learned about how to work with numbers using commands such as [`pmin()`](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Extremes.html) with the **nycflights13** package.

You learned about some of the power of the [**stringr**](https://stringr.tidyverse.org/) package: how to create, combine, and extract strings with the **babynames** package.

```{r download-answers, child = system.file("child_documents/download_answers.Rmd", package = "tutorial.helpers")}
```

```         
STRING KNOWLEDGE DROPS

### 1

You might be wondering what tibble is, A tibble is a new form of a data frame in R that is part of the tidyverse library, and tibbles print the data in a more efficient format than a data frame, showing the values of the columns, their datatype, and the size of the dataset.

### 2

The `babynames` is a data set which contained names used for babies from 1880 to 2017. If you want to explore the data set, checkout [popular baby names](https://www.ssa.gov/oact/babynames/limits.html).### 

### 3

To check for `NA` values, use `any()` function with argument `is.na()`, argument of which should be the dataset babynames. 

### 4

We’ve created strings in passing earlier in the book but didn’t discuss the details. Firstly, you can create a string using either single quotes (') or double quotes ("). If you wanted to include single quotes in a string you could put the outer quotes as double quotes.

Now there’s no difference in behavior between the single quotes and double quotes, but in the interests of consistency, the [*Tidyverse*](https://style.tidyverse.org/syntax.html#character-vectors) style guide recommends using `"`, unless the string itself contains double quotes.

### 5

The **stringr** library is a part of the [*Tidyverse*](https://www.tidyverse.org/). We can just load the **tidyverse** library and the **stringr** library will be automatically loaded. 

### 6

The printed representation of a string is not the same as the string itself because the printed representation shows the escapes. To see the raw contents of the string, we use `str_view()`

### 7

There's another way to include quotes in a string. To include a literal single or double quote, you can use the backslash `\` to escape it. For example, `"\""` will return `'"'`. To include a literal backlash in your string, it is pretty simple and all you need to do is have two backslashes in a string to have one literal one. 

### 8

If you find yourself dealing with a complex situation where you have many backslashes and quotes to include, it can become confusing to keep track of them. (This is sometimes called [leaning toothpick syndrome](https://en.wikipedia.org/wiki/Leaning_toothpick_syndrome).)

To solve the issue, we utilized a raw string, which is a specific type of string literal that doesn't interpret any special characters or escape sequences.

Typically, a raw string starts with `r"(, ends with )"`, and allows for any text representation. However, if the string contains )", alternatives like `r"[]"` or `r"{}"` can be used. Furthermore, you can add dashes to ensure unique opening and closing pairs, such as `r"--()--"`, `r"---()---"`, and so on. Raw strings offer flexibility to handle any text without problems.

### 9

Besides `\"`, `\'`, and `\\`, there are a few other special characters that can be useful. The most common ones are `\n` for a new line and `\t` for a tab. If you want to check out a complete list of other special characters, check out in [Quotes](https://rdrr.io/r/base/Quotes.html).
 
### 10

`str_c()` is a function in the `stringr` package in R that combines multiple character vectors into a single character vector. It is similar to the `paste()` function, but it uses `tidyverse` recycling and NA rules. `str_c()` is vectorized, which means it can take multiple arguments and combine them element-wise. 

### 11

If you are mixing many fixed and variable strings with `str_c()`, you’ll notice that you type a lot of `"`s, making it hard to see the overall goal of the code. An alternative approach is provided by the glue package via `str_glue()`. How `str_glue()` works is that if you give it a single string that has a special feature: anything inside `{}` will be evaluated like it’s outside of the quotes. However, `str_glue()` currently converts missing values to the string "NA" unfortunately making it inconsistent with `str_c()`.

### 12

`str_c()` and `str_glue()` are suitable for use with `mutate()` since their output matches the length of their inputs. However, if you need a function that works well with `summarize()` and always returns a single string, `str_flatten()` comes into play. It takes a character vector as input and combines each element of the vector into a single string.

### 13

One variation of `str_flatten()` is `str_flatten_comma()` is a variation designed specifically for flattening with commas. It automatically recognizes if last uses the Oxford comma and handles the special case of 2 elements.

### 14

The `last` argument is an optional string to use in place of the final separator.

### 15

`summarize()` creates a new data frame. It returns one row for each combination of grouping variables; if there are no grouping variables, the output will have a single row summarizing all observations in the input.

### 16

The `.by` arguement is a selection of columns to group by for just this operation, functioning as an alternative to `group_by()`. For details and examples, see `?dplyr_by`.

To review, `mutate()` either changes an existing column or adds a new one. `summarize()` calculates a single value (per group).

### 17

Separating a string into rows tends to be most useful when the number of components varies from row to row. The most common case is requiring `separate_longer_delim()` to split based on a delimiter.

### 18

Just like with `pivot_longer()` and `pivot_wider()`, `_longer` like `separate_longer_delim()` functions make the input data frame longer by creating new rows and `_wider` functions make the input data frame wider by generating new columns.

### 19

If you are wondering what `delim = ","` means, the `delim` argument is used to specify the delimiter character in functions that involve reading or writing delimited data files.

For example, when reading a CSV (Comma-Separated Values) file using the `read_delim()` function from the **readr** package, you can specify `delim = ","` to indicate that the values in the file are separated by commas. 

### 20

As you look at the tibble, notice we can't separate the numbers by commas to make the column longer. That's where `separate_longer_position()` comes into the play.

### 21

If you don't want a column, all we have to do rename to column to be `NA`

### 22

What if you want to separate them by different width in position? `separate_wider_position()` is the function that solves that.

`separate_wider_position()` works a little differently because you typically want to specify the width of each column. So you give it a named integer vector, where the name gives the name of the new column, and the value is the number of characters it occupies. You can omit values from the output by not naming them

### 23

In response to not having the same number of pieces, there are two possible problems, too few or too many pieces, so `separate_wider_delim()` provides two arguments to help: `too_few` and `too_many`.

### 24

When you use the debug mode, you get three extra columns added to the output: `x_ok`, `x_pieces`, and `x_remainder` (if you separate a variable with a different name, you’ll get a different prefix).

`x_pieces` tells us how many pieces were found, compared to the expected 3 (the length of names). `x_remainder` isn’t useful when there are too few pieces, but we’ll see it again shortly

### 25

In other cases, you may want to fill in the missing pieces with `NA`s and move on. That’s the job of `too_few` = `"align_start"` and `too_few` = `"align_end"` which allow you to control where the `NA`s should go.

### 26

You will get an error and get suggestions to use `too_many = "debug"` or `too_many = "drop/merge"`. We will use "debug" to see what being kept and what's being left and after that we will talk about use drop and merge.

When we debug the result, you can see the purpose of `x_remainder`: it shows what was left behind and not inserted into the columns.

As we are already aware by the word `drop`, it has been established that Rstudio will discard the remaining x remainders.

### 27

`str_length()` tells you the number of letters in the string.

`str_length()` not only counts the letters but also the spaces in between the words in a string. If you want to explore more, check out [`str_length()`](https://stringr.tidyverse.org/reference/str_length.html).

### 28

In RStudio, the `==` operator is used to test for equality between two values. It is a comparison operator that returns a logical value of TRUE if the values are equal and FALSE otherwise. 

### 29

You can extract parts of a string using `str_sub(string, start, end)`, where start and end are the positions where the substring should start and end. 

To extract a substring using the `str_sub()` function, specify the following arguments: the first argument should be the variable `y` that we have defined, the second argument should be the starting position (1 in this case), and the third argument should be the ending position (3 in this case).

Looking at results, when using `str_sub()`The start and end arguments are inclusive, so the length of the returned string will be end - start + 1

If you want to look at the end of the string, you can use negative values to count back from the end of the string: -1 is the last character, -2 is the second to last character, etc. Note that `str_sub()` won’t fail if the string is too short: it will just return as much as possible

### 30

If you didnt know, In Python, indexing starts from zero, whereas in RStudio, indexing starts from one, resulting in a slight variation in accessing elements and slicing sequences.


KNOWLEDGE DROPS FROM tutorials 9, 10, 11

(Not all of them!) Just the 20 or so you think are best. No need to number them.
```

The [**ggrepel**](https://ggrepel.slowkow.com) package will automatically adjust labels so that they don’t overlap. To help others quickly build up a good mental model of the data, you will need to invest considerable effort in making your plots as self-explanatory as possible.

Another handy function for adding annotations to plots is `annotate()`. As a rule of thumb, geoms are generally useful for highlighting a subset of the data while `annotate()` is useful for adding one or few annotation elements to a plot.

We can see that the two plots are the same. Note the naming scheme for scales: `scale_` followed by the name of the aesthetic, then `_`, then the name of the scale. The default scales are named according to the type of variable they align with: `continuous`, `discrete`, `datetime`, or `date`.

Another scale that is frequently customized is color. The default categorical scale picks colors that are evenly spaced around the color wheel. Useful alternatives are the ColorBrewer scales which have been hand-tuned to work better for people with common types of color blindness.

You can use labels in the same way (a character vector the same length as breaks), but you can also set it to NULL to suppress the labels altogether. This can be useful for maps, or for publishing plots where you do want to share the absolute numbers.

In addition to `geom_text()` and `geom_label()`, you have many other geoms in **ggplot2** available to help annotate your plot. For example, you can use `geom_hline()` and `geom_vline()` to add reference lines. We often make them thick (`linewidth = 2`) and white (`color = "white"`), and draw them underneath the primary data layer. That makes them easy to see, without drawing attention away from the data.

As always, `ggplot()` alone, without the use of the `aes()` function as an argument to `mapping`, produces an empty rectangle.

The function, `geom_freqpoly()`, visualizes the distribution of a single continuous variable by dividing the x-axis into bins and counting the number of observations in each bin. Frequency polygons display the counts with lines. Frequency polygons are more suitable when you want to compare the distribution across the levels of a categorical variable.

`geom_bin2d()` and `geom_hex()` divide the coordinate plane into 2d bins and then use a fill color to display how many points fall into each bin. `geom_bin2d()` creates rectangular bins. `geom_hex()` creates hexagonal bins. You will need to install the **hexbin** package to use `geom_hex()`.

If two variables covary, you can use the values of one variable to make better predictions about the values of the second. If the covariation is due to a causal relationship (a special case), then you can use the value of one variable to control the value of the second.

The function [`linear_reg()`](https://parsnip.tidymodels.org/reference/linear_reg.html) defines a model that can predict numeric values from predictors using a linear function. This function can fit regression models. There are different ways to fit this model, and the method of estimation is chosen by setting the model `engine`.

EDA is not a formal process with a strict set of rules. More than anything, EDA is a state of mind. During the initial phases of EDA you should feel free to investigate every idea that occurs to you. Some of these ideas will pan out, and some will be dead ends.

Covariation is the tendency for the values of two or more variables to vary together in a related way. The best way to spot covariation is to visualize the relationship between two or more variables.

If two variables covary, you can use the values of one variable to make better predictions about the values of the second. If the covariation is due to a causal relationship (a special case), then you can use the value of one variable to control the value of the second.

Mapping an unordered discrete (categorical) variable, like `class`, to an ordered aesthetic, like `size` is generally not a good idea because it implies a ranking that does not in fact exist, hence the warning.

Once you map an aesthetic, **ggplot2** takes care of the rest. It selects a reasonable scale to use with the aesthetic, and it constructs a legend that explains the mapping between levels and values. For x and y aesthetics, **ggplot2** does not create a legend, but it creates an axis line with tick marks and a label. The axis line provides the same information as a legend; it explains the mapping between locations and values.

The `geom_smooth()` geom is applied to each category of color separately. With one call to a geom, we get three different plots, all on the same graph. There are no front-wheel drive cars with a `displ` value greater than 5, so the green line does not extend to the right-side of the graphic.

To facet your plot by a single variable, use `facet_wrap()`. The first argument of `facet_wrap()` is a formula, which you create with `~` followed by a variable name. The variable that you pass to `facet_wrap()` should be categorical, i.e., either character or factor.

Adding randomness seems like a strange way to improve your plot, but while it makes your graph less accurate at small scales, it makes your graph more revealing at large scales. Because this is such a useful operation, **ggplot2** comes with a shorthand for `geom_point(position = "jitter")`: `geom_jitter()`.

We use scale_y_continuous when we want to modify the y-axis for continuous data. [This documentation here](https://ggplot2.tidyverse.org/reference/scale_continuous.html) will tell you more, and all the possible arguments you can use with `scale_y_continuous`
